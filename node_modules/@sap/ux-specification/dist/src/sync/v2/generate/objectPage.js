"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const utils_1 = require("./utils");
const import_1 = require("../import");
const v2_1 = require("../../../v2");
const extensionLogger_1 = require("../../../extensionLogger");
const common_2 = require("../../../specification/common");
const i18next_1 = __importDefault(require("i18next"));
const i18n_1 = require("../../../i18n/i18n");
const types_1 = require("../types");
/**
 * Adds flexChange properties for sub(sections)
 * @param appSchema - app schema in general
 * @param schemaSection - current section
 * @param property - property that will be enhanced
 * @param sectionType - type of section
 */
function addFlexChangeForSection(appSchema, schemaSection, property, sectionType) {
    let controlType;
    switch (sectionType) {
        case types_1.SectionTypeV2.Section:
        case types_1.SectionTypeV2.SectionForm:
        case types_1.SectionTypeV2.SectionChart:
        case types_1.SectionTypeV2.SectionTable:
            controlType = v2_1.ControlType.Section;
            break;
        case types_1.SectionTypeV2.SubSection:
            controlType = v2_1.ControlType.SubSection;
            break;
        case types_1.SectionTypeV2.SubSectionForm:
            controlType = v2_1.ControlType.SmartGroup;
            break;
        case types_1.SectionTypeV2.SubSectionChart:
            controlType = v2_1.ControlType.SmartChart;
            break;
        case types_1.SectionTypeV2.SubSectionTable:
            controlType = v2_1.ControlType.SmartTable;
            break;
    }
    if (controlType === undefined) {
        return;
    }
    common_1.addPatternForBindingChangeOfEnumOP(appSchema, schemaSection, property);
    schemaSection['properties'][property].artifactType = 'FlexChange';
    schemaSection['properties'][property].controlType = controlType;
}
/**
 * Callback for adding a single action to headerActions of V2
 * @param {EntityType} entityType - current entity type
 * @param {object} appSchema Schema of the app
 * @param actionAnnotation - annotation as present in AVT ConverterOutput
 * @param headerActions - list of header actions, to be enhanced
 */
function addHeaderActionCallBackV2(entityType, appSchema, actionAnnotation, headerActions, oDataServiceAVT) {
    return (item, index) => {
        if (!item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
            const action = common_1.replaceAlias(item.Action, oDataServiceAVT);
            const { actionName, actionId } = common_1.getActionNameAndId(action, entityType);
            const description = item.Label || actionName;
            const actionDefinitionKey = `HeaderAction<${common_1.prepareRef(actionId)}>`;
            appSchema['definitions'][actionDefinitionKey] = JSON.parse(JSON.stringify(appSchema['definitions']['HeaderAction']));
            const convertedIdentification = actionAnnotation.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* Identification */}`);
            appSchema['definitions'][actionDefinitionKey].annotationPath = `/${convertedIdentification}/${index}`;
            appSchema['definitions'][actionDefinitionKey].description = description;
            headerActions.properties[actionId] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
            };
        }
    };
}
/**
 * Method ensures that definitions for custom columns are created for passed entitySet.
 * @param {object} appSchema App schema in general
 * @param {object} manifest manifest.json of the app
 * @param {string} entitySetName Entity set name.
 * @param {string} entityTypeName Entity type name.
 * @param {ConverterOutput} oDataServiceAVT Complete service information, as returned by annotation vocabularies tool
 * @param {FileData[]} [fragments] Array with XML fragments.
 * @return {string} Name of custom columns definition.
 */
function ensureCustomColumnDefinitionExists(appSchema, manifest, entitySetName, entityTypeName, oDataServiceAVT, fragments) {
    const customColumnsDefinitionName = `${utils_1.CUSTOM_COLUMNS_DEFINITION}<${entitySetName}>`;
    if (appSchema['definitions'][customColumnsDefinitionName]) {
        // Definition is already created - we do not need to create it again
        return utils_1.CUSTOM_COLUMNS_DEFINITION;
    }
    // Create type specific 'TableCustomColumn' definition - use entity set as type.
    const customColumnDefinitionName = `${utils_1.CUSTOM_COLUMN_DEFINITION}<${entitySetName}>`;
    const customColumnDefinition = JSON.parse(JSON.stringify(appSchema['definitions']['TableCustomColumn']));
    appSchema['definitions'][customColumnDefinitionName] = customColumnDefinition;
    // Update definitions for type specific custom columns
    const pageKeys = [];
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    const v2Page = import_1.findObjectPageV2(manifest[common_2.ManifestSection.generic].pages, entitySetName, pageKeys);
    utils_1.addListReportColumnExtensions(appSchema, entityType, v2Page, manifest, fragments, customColumnsDefinitionName, customColumnDefinitionName);
    return customColumnsDefinitionName;
}
/**
 * Reuse function for all table types, copies and adapts the generic definition
 * @param tableType - Table type
 * @param facetId - facet ID, as derived for the given section
 * @param facet - facet or section information
 * @param appSchema - app-specific schema, to be updated
 */
function addTableDefinition(tableType, facetId, facet, appSchema) {
    const schemaId = common_1.prepareRef(`${tableType}<${facetId}>`);
    appSchema['definitions'][schemaId] = JSON.parse(JSON.stringify(appSchema['definitions'][tableType]));
    appSchema['definitions'][schemaId]['properties']['columns']['$ref'] = common_1.DEFINITION_LINK_PREFIX + facetId;
    appSchema['definitions'][schemaId].properties.toolBar.$ref = `${common_1.DEFINITION_LINK_PREFIX}ObjectPageToolBar<${facetId}>`;
    appSchema['definitions'][schemaId].annotationPath = facet.annotationPath;
    if (facet.ID !== undefined) {
        appSchema['definitions'][schemaId].title = common_1.FacetTitlePrefix + facet.ID;
    }
    appSchema['definitions'][schemaId].description = 'Table';
    //adjust quickVariantSelection
    appSchema['definitions'][schemaId].properties['quickVariantSelection'].$ref = `${common_1.DEFINITION_LINK_PREFIX}QuickVariantSelectionOP<${facetId}>`;
    appSchema['definitions'][`QuickVariantSelectionOP<${facetId}>`] = JSON.parse(JSON.stringify(appSchema['definitions']['QuickVariantSelectionOP']));
    appSchema['definitions'][`QuickVariant<${facetId}>`] = JSON.parse(JSON.stringify(appSchema['definitions']['QuickVariant']));
    appSchema['definitions'][`QuickVariantSelectionOP<${facetId}>`].properties.variants.patternProperties['^[0-9]+$'].$ref = `QuickVariant<${facetId}>`;
    common_1.addEnumForSingleTabVariant(facet.entityType, appSchema, `QuickVariant<${facetId}>`);
}
/**
 * Adds definitions for line items in object page sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {string} facetId - key of the facet, as listed in FacetConfigs
 * @param {object} appSchema - app schema in general
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {FacetConfigs} facets - list of all facets
 */
function handleLineItem(generateParameters, facetId, appSchema, facet, facets, sectionType) {
    var _a;
    if (facet.base !== 'LineItem' || !facetId) {
        //no properties
        return;
    }
    const navigationProperty = facetId.split('::')[0];
    const schemaIdForOpSection = `${sectionType}<${facetId}>`;
    appSchema['definitions'][schemaIdForOpSection] = common_1.createSectionWithoutProperties(facet, facetId);
    const appSchemaSection = appSchema['definitions'][schemaIdForOpSection];
    if (facet.ID || ((_a = facet.target) === null || _a === void 0 ? void 0 : _a['qualifier'])) {
        appSchemaSection.properties = JSON.parse(JSON.stringify(appSchema['definitions'][types_1.SectionTypeV2.SectionTable]['properties']));
        if (appSchemaSection.properties.visible) {
            addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
        }
    }
    else {
        appSchemaSection.properties.table = JSON.parse(JSON.stringify(appSchema['definitions'][types_1.SectionTypeV2.SectionTable]['properties']['table']));
    }
    appSchemaSection.properties.table.anyOf = [
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithMultiSelect<${facetId}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithInlineDelete<${facetId}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageAnalyticalTable<${facetId}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageGridTable<${facetId}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageTreeTable<${facetId}>`
        }
    ];
    appSchemaSection.annotationPath = facet.annotationPath;
    common_1.addSectionTitleAndDescription(facet, appSchemaSection, facetId);
    // Find target entity
    const targetEntity = facet.entityType
        ? generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT.entitySets.find((es) => es.entityType.name === facet.entityType.name || es.name === facet.entityType.name) : undefined;
    addTableDefinition('ObjectPageResponsiveTableWithMultiSelect', facetId, facet, appSchema);
    addTableDefinition('ObjectPageResponsiveTableWithInlineDelete', facetId, facet, appSchema);
    addTableDefinition('ObjectPageGridTable', facetId, facet, appSchema);
    addTableDefinition('ObjectPageTreeTable', facetId, facet, appSchema);
    addTableDefinition('ObjectPageAnalyticalTable', facetId, facet, appSchema);
    let customColumnDefinitionKey;
    if (targetEntity) {
        // Make sure that custom columns definitions are created for passed entity
        customColumnDefinitionKey = ensureCustomColumnDefinitionExists(appSchema, generateParameters.manifest, targetEntity.name, facet.entityType.name, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, generateParameters.fragments);
    }
    for (const facetKey in facets) {
        if (facets[facetKey].base === 'LineItem' && facetKey.includes(navigationProperty)) {
            utils_1.addLineItemsType(appSchema, facets[facetKey].target, facets[facetKey].entityType, facetId, customColumnDefinitionKey);
        }
    }
}
/**
 * Adds definitions for subsections in object page sections to the app schema
 * @param facetId - key of the facet, as listed in FacetConfigs
 * @param appSchema - app schema in general
 * @param facet - the given facet from the UI annotations
 * @param facets - list of all facets
 */
function handleSubSection(facetId, appSchema, facet, sectionType) {
    const schemaIdForSection = facetId.replace(`@${"com.sap.vocabularies.UI.v1.Facets" /* Facets */}`, facet.base);
    const definitionKey = `${sectionType}<${schemaIdForSection}>`;
    appSchema['definitions'][definitionKey] = common_1.createSectionWithoutProperties(facet, facetId);
    const appSchemaSection = appSchema['definitions'][definitionKey];
    if (facet.ID) {
        appSchemaSection.properties = JSON.parse(JSON.stringify(appSchema['definitions'][types_1.SectionTypeV2.SubSection]['properties']));
        if (appSchemaSection.properties.visible) {
            addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
        }
    }
    appSchemaSection.properties.subsections = {
        type: 'object',
        description: 'Subsections',
        properties: {},
        additionalProperties: false,
        isViewNode: true
    };
}
/**
 * Creates a section definition in app schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {FacetConfigs} facets - list of all facets.
 * @param {string} facetKey - facet key.
 * @param {object} sections - schema of current sections definition.
 * @param {object} appSchema - app specific schema that potentially gets enhanced.
 */
function addSection(generateParameters, facets, facetKey, sections, appSchema, isSubSection = false) {
    var _a;
    const facet = facets[facetKey];
    switch (facet.base) {
        case v2_1.FacetBase.CollectionFacet: {
            //handle collection facets
            const sectionType = (sections === null || sections === void 0 ? void 0 : sections['description']) === 'Subsections' ? types_1.SectionTypeV2.SubSection : types_1.SectionTypeV2.Section;
            const schemaIdForSection = facetKey.replace(`@${"com.sap.vocabularies.UI.v1.Facets" /* Facets */}`, facet.base);
            isSubSection = true;
            const definitionKey = `${sectionType}<${schemaIdForSection}>`;
            sections['properties'][schemaIdForSection] = { $ref: `${common_1.DEFINITION_LINK_PREFIX}${definitionKey}` };
            handleSubSection(facetKey, appSchema, facet, sectionType);
            const subSections = appSchema['definitions'][definitionKey].properties.subsections;
            for (const key in facet['facets']) {
                addSection(generateParameters, facet['facets'], key, subSections, appSchema, isSubSection);
            }
            break;
        }
        case v2_1.FacetBase.LineItem: {
            //handle reference facet (if comprising line item)
            const sectionType = isSubSection ? types_1.SectionTypeV2.SubSectionTable : types_1.SectionTypeV2.SectionTable;
            sections['properties'][facetKey] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${sectionType}<${facetKey}>`
            };
            handleLineItem(generateParameters, facetKey, appSchema, facet, facets, sectionType);
            //add fields for createWithParameterDialog
            const floorplanSuffix = 'OP';
            common_1.addFieldsType(appSchema, facet.entityType, floorplanSuffix);
            break;
        }
        case v2_1.FacetBase.Chart: {
            //handle reference facet (if comprising chart)
            const sectionType = isSubSection ? types_1.SectionTypeV2.SubSectionChart : types_1.SectionTypeV2.SectionChart;
            const definitionKey = `${sectionType}<${facetKey}>`;
            sections['properties'][facetKey] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${definitionKey}`
            };
            appSchema['definitions'][definitionKey] = common_1.createSectionWithoutProperties(facet, facetKey);
            const appSchemaSection = appSchema['definitions'][definitionKey];
            if (facet.ID) {
                appSchemaSection.properties = JSON.parse(JSON.stringify(appSchema['definitions'][types_1.SectionTypeV2.SectionChart]['properties']));
                if (appSchemaSection.properties.visible) {
                    addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
                }
            }
            break;
        }
        case v2_1.FacetBase.Form:
        case v2_1.FacetBase.Identification: {
            const sectionType = isSubSection ? types_1.SectionTypeV2.SubSectionForm : types_1.SectionTypeV2.SectionForm;
            const definitionKey = `${sectionType}<${facetKey}>`;
            sections['properties'][facetKey] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${definitionKey}`
            };
            appSchema['definitions'][definitionKey] = common_1.createSectionWithoutProperties(facet, facetKey);
            const appSchemaSection = appSchema['definitions'][definitionKey];
            if ((facet === null || facet === void 0 ? void 0 : facet.ID) || ((_a = facet.target) === null || _a === void 0 ? void 0 : _a['qualifier'])) {
                appSchemaSection['properties'] = JSON.parse(JSON.stringify(appSchema['definitions'][types_1.SectionTypeV2.SectionForm]['properties']));
                if (appSchemaSection.properties.visible) {
                    addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
                }
            }
            if (facet === null || facet === void 0 ? void 0 : facet.ID) {
                appSchemaSection.title = common_1.FacetTitlePrefix + facet.ID;
            }
            if (facet === null || facet === void 0 ? void 0 : facet.Label) {
                appSchemaSection.description = facet.Label;
            }
            let withActions = true;
            appSchemaSection.annotationPath = facet.annotationPath;
            appSchemaSection.isViewNode = true;
            if (!appSchemaSection.description) {
                if (facet.base === v2_1.FacetBase.Form) {
                    appSchemaSection.description = 'Form';
                }
                else if (facet.base === 'Identification') {
                    appSchemaSection.description = 'Identification';
                    withActions = false;
                }
            }
            common_1.handleForm(v2_1.SectionType.Section, facet, appSchemaSection, appSchema, common_2.FioriElementsVersion.v2, withActions);
            break;
        }
        default: {
            // Other facets -> no properties
            sections['properties'][facetKey] = common_1.createSectionWithoutProperties(facet, facetKey);
        }
    }
}
/**
 * Adds the sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {object} appSchema - app specific schema that potentially gets enhanced
 * @param {EntityType} entityType - current entity type
 * @param {SapUiAppPagesV2} pages - list of (manifest) pages
 */
function addSections(generateParameters, appSchema, entityType, entitySetName, pages) {
    //initialize sections
    const sections = (appSchema['definitions']['Sections'] = {
        type: 'object',
        properties: {},
        description: 'Sections',
        additionalProperties: false,
        isViewNode: true
    });
    if (entityType) {
        sections['annotationPath'] = `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Facets" /* Facets */}`;
    }
    if (!pages) {
        return;
    }
    // Get facet annotations
    const facets = common_1.getObjectPageFacets(entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, common_2.FioriElementsVersion.v2, generateParameters.logger);
    if (!facets || Object.keys(facets).length === 0) {
        return;
    }
    // Loop on all pages, look for the right entity set
    for (const key in pages) {
        const element = pages[key];
        if (entitySetName.includes(element.entitySet)) {
            // Loop on all facets (of the given entitySet)
            for (const facetKey in facets) {
                addSection(generateParameters, facets, facetKey, sections, appSchema);
            }
        }
        else {
            addSections(generateParameters, appSchema, entityType, entitySetName, element.pages);
        }
    }
    // Add custom sections
    for (const name in appSchema['definitions']['CustomSections'].properties) {
        sections.properties[name] = appSchema['definitions']['CustomSections'].properties[name];
    }
}
/**
 * Add Object Page Header to app-specific schema
 *
 * @param {object} appSchema Schema of the app
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function addHeader(appSchema, entityType, oDataServiceAVT) {
    common_1.addCommonHeaderSchema(appSchema, entityType);
    //Add header actions
    common_1.addHeaderActions(appSchema, entityType, oDataServiceAVT, addHeaderActionCallBackV2);
}
/**
 * Adds the related facets keys 'enum' to the app schema
 * @param schema - app specific schema that potentially gets enhanced
 * @param {EntityType} entityType - current entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addRelatedFacetKeysType(schema, entityType, oDataServiceAVT, logger) {
    // Find sections from annotation
    // And create new definition in schema as enum with description
    const facetSections = common_1.getObjectPageFacetSection(entityType, oDataServiceAVT, logger, undefined, true);
    if (facetSections) {
        common_1.addDefinitionForRelatedFacetKeys(schema, ['ObjectPageCustomSectionFragment', 'ObjectPageCustomSectionView'], facetSections, ['ID', 'key']);
    }
}
/**
 * Generates an app specific schema out of the generic schema.
 * Generic types are replaced by information from the app specific annotations.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param genericSchema - generic JSON schema of an object page
 * @param entityTypeName - the base entity type of the given page
 *
 * @returns the app specific JSON schema
 */
function generateObjectPageSchemaV2(generateParameters, genericSchema, entityTypeName) {
    // Initialize i18next
    i18n_1.initI18n();
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    // Custom sections as part of sections
    const additionalSections = {};
    for (const name in appSchema['definitions']['CustomSections'].properties) {
        additionalSections[name] = appSchema['definitions']['CustomSections'].properties[name];
    }
    // Change reference to generated sections
    appSchema['properties']['sections'] = {
        $ref: common_1.DEFINITION_LINK_PREFIX + 'Sections'
    };
    const entitySet = (generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT.entitySets) && (generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT.entitySets.find((es) => es.entityType.name === entityTypeName || es.name === entityTypeName));
    if (!entitySet) {
        extensionLogger_1.log(generateParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOENTITYSET4NAME', { entityType: entityTypeName }),
            location: {
                path: common_1.METADATAPATH
            }
        });
        return;
    }
    const entityType = entitySet === null || entitySet === void 0 ? void 0 : entitySet.entityType;
    const pages = generateParameters.manifest[common_2.ManifestSection.generic].pages;
    if (!pages) {
        extensionLogger_1.log(generateParameters.logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [common_2.ManifestSection.generic]
            }
        });
        return appSchema;
    }
    // Add header
    addHeader(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
    // Add sections
    addSections(generateParameters, appSchema, entityType, entitySet.name, pages);
    // Custom section facets
    addRelatedFacetKeysType(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT, generateParameters.logger);
    // Remove Custom Column non existing extensions - TreeTableColumnsExtension does not exist in ALP
    utils_1.removeElementsFromEnum(appSchema['definitions']['TableColumnExtensionTypeV2']['enum'], [
        v2_1.TableColumnExtensionTypeV2.TreeTableColumnsExtension
    ]);
    if (!appSchema['definitions']['Sections']) {
        if (appSchema['definitions']['RelatedFacetKeys'] &&
            appSchema['definitions']['RelatedFacetKeys']['oneOf'].length) {
            // If related facets exists - then we need sections definition
            appSchema['definitions']['Sections'] = {
                type: 'object',
                properties: additionalSections,
                additionalProperties: false,
                isViewNode: true
            };
        }
        else {
            delete appSchema['properties']['sections'];
        }
    }
    common_1.addFooterActions(appSchema, entityType, generateParameters === null || generateParameters === void 0 ? void 0 : generateParameters.serviceAVT);
    // Eliminate generic definitions
    delete appSchema['definitions']['GenericSections'];
    delete appSchema['definitions']['ObjectPageSectionTableV2'];
    delete appSchema['definitions']['GenericColumns'];
    delete appSchema['definitions']['ObjectPageSectionFormV2'];
    delete appSchema['definitions']['ObjectPageSectionTableV2'];
    delete appSchema['definitions']['ObjectPageSubSectionV2'];
    delete appSchema['definitions']['ObjectPageResponsiveTableWithMultiSelect'];
    delete appSchema['definitions']['ObjectPageResponsiveTableWithInlineDelete'];
    delete appSchema['definitions']['ObjectPageAnalyticalTable'];
    delete appSchema['definitions']['ObjectPageTreeTable'];
    delete appSchema['definitions']['ObjectPageGridTable'];
    delete appSchema['definitions']['ObjectPageToolBar'];
    delete appSchema['definitions']['ObjectPageToolBarActions'];
    delete appSchema['definitions']['ObjectPageToolBarAction'];
    delete appSchema['definitions']['ObjectPageForm'];
    delete appSchema['definitions']['ObjectPageFormFields'];
    delete appSchema['definitions']['ObjectPageFormActions'];
    return appSchema;
}
exports.generateObjectPageSchemaV2 = generateObjectPageSchemaV2;
//# sourceMappingURL=objectPage.js.map