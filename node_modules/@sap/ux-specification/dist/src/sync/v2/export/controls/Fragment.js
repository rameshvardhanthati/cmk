"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../../common/types");
const xml_js_1 = require("xml-js");
const view_controller_generator_1 = require("../view-controller-generator");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../../extensionLogger");
const v2_1 = require("../../../../specification/v2");
const manifest_1 = require("../manifest");
const path_1 = require("path");
exports.FRAGMENT_DEFINITION = 'core:FragmentDefinition';
const VIEW_TEMPLATE_TAGNAME_MAP = new Map([
    [types_1.ViewTemplateType.AnalyticalTableColumnsExtension, 'table:AnalyticalColumn'],
    [types_1.ViewTemplateType.ResponsiveTableColumnsExtension, 'Column'],
    [types_1.ViewTemplateType.TreeTableColumnsExtension, 'table:Column'],
    [types_1.ViewTemplateType.GridTableColumnsExtension, 'table:Column']
]);
const FE_TEMPLATE_VIEW_EXTENSION_MAP = new Map([
    [v2_1.FE_TEMPLATE_V2_LIST_REPORT, v2_1.SAPUI5_VIEW_EXTENSION_LIST_REPORT],
    [v2_1.FE_TEMPLATE_V2_ALP, v2_1.SAPUI5_VIEW_EXTENSION_ANALYTICAL_LIST_PAGE],
    [v2_1.FE_TEMPLATE_V2_OBJECT_PAGE, v2_1.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE]
]);
const dummyEntry = {
    type: 'element',
    name: 'Text',
    attributes: { text: 'Placeholder' }
};
const dummyEntryAsString = JSON.stringify(dummyEntry);
/**
 * Method which receives fragment definition node and returns 'tag' name of root column definition.
 * There is different column definition names - method resolves them.
 * For example 'Column', 'table:Column', etc.
 * @param {unknown} definition - Application or Page Config object.
 * @returns {unknown | undefined} Root column tag name.
 */
function getTagNameFromFragmentJSON(definition) {
    const keys = VIEW_TEMPLATE_TAGNAME_MAP.keys();
    for (const key of keys) {
        const tagName = VIEW_TEMPLATE_TAGNAME_MAP.get(key);
        if (definition[tagName]) {
            return tagName;
        }
    }
}
exports.getTagNameFromFragmentJSON = getTagNameFromFragmentJSON;
/**
 * Method which receives fragment definition node and reads root column definition.
 * @param {unknown} definition - Application or Page Config object.
 * @returns {unknown | undefined} Root column read from definition.
 */
function getRootCustomColumnFromFragmentJSON(definition) {
    const name = getTagNameFromFragmentJSON(definition);
    return definition[name];
}
exports.getRootCustomColumnFromFragmentJSON = getRootCustomColumnFromFragmentJSON;
/**
 * Internal function handling a single fragment column if detected in the fragment
 * @param columnsInFragment - list of all columns in fragment
 * @param configColumns - list of all columns in the config
 */
function handleFragmentColumn(columnsInFragment, configColumns) {
    let foundInConfig = false;
    const customData = columnsInFragment['customData'] || columnsInFragment['table:customData'];
    if (!customData) {
        return false;
    }
    let p13nData = customData['core:CustomData']._attributes.value;
    const columnParts = JSON.parse(p13nData.substr(1, p13nData.length));
    const ix = configColumns.findIndex((column) => {
        return column.columnKey === columnParts.columnKey;
    });
    if (ix < 0) {
        return false;
    }
    //Found ==> update scenario
    foundInConfig = true;
    p13nData = '\\{"columnKey": "' + configColumns[ix].columnKey + '"';
    if (configColumns[ix].columnIndex !== undefined) {
        p13nData += ', "columnIndex": "' + configColumns[ix].columnIndex.toString() + '"';
    }
    if (configColumns[ix].leadingProperty) {
        p13nData += ', "leadingProperty": "' + configColumns[ix].leadingProperty + '"';
    }
    p13nData += '}';
    customData['core:CustomData']._attributes.value = p13nData;
    if (!columnsInFragment['Text'] && !columnsInFragment['Label']) {
        columnsInFragment['Text'] = {
            _attributes: {}
        };
    }
    if (columnsInFragment['Text']) {
        columnsInFragment['Text']._attributes['text'] = configColumns[ix].text;
    }
    else if (columnsInFragment['Label']) {
        columnsInFragment['Label']._attributes['text'] = configColumns[ix].text;
    }
    if (!columnsInFragment['_attributes']) {
        columnsInFragment['_attributes'] = {};
    }
    columnsInFragment['_attributes']['id'] = configColumns[ix].id;
    configColumns.splice(ix, 1);
    return foundInConfig;
}
/**
 * Identifies the right extensions based on a pattern, then deletes all corresponding columns and cells
 * @param manifestSection - Section in manifest.json comprising the extensions
 * @param pattern - Search string to identify the extension in manifest
 * @param appId - application ID
 * @param fragments - list of all fragments
 */
function deleteColumnFromFragment(manifestSection, pattern, appId, fragments) {
    if (fragments) {
        //delete columns
        let fragmentId = manifestSection[pattern].fragmentName.substr(appId.length + 1);
        let fragmentType = manifestSection['type'] ? manifestSection['type'].toLowerCase() : 'xml';
        let fragmentParts = fragmentId.split('.');
        let fragmentName = fragmentParts[fragmentParts.length - 1] + types_1.FRAGMENTNAMEPART + fragmentType;
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            const fragmentPathArray = fragment['dataSourceUri'].split(path_1.sep);
            if (fragmentPathArray[fragmentPathArray.length - 1] === fragmentName) {
                //fragments.splice(i, 1);
                const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent, { compact: true }));
                const tagName = getTagNameFromFragmentJSON(fragmentJson[exports.FRAGMENT_DEFINITION]);
                if (tagName) {
                    delete fragmentJson[exports.FRAGMENT_DEFINITION][tagName];
                    fragment.fileContent = xml_js_1.json2xml(JSON.stringify(fragmentJson), { compact: true, spaces: 4 });
                }
                break;
            }
        }
        //delete cells
        const cellsPath = pattern.replace(types_1.ViewTemplateType.ResponsiveTableColumnsExtension, types_1.ViewTemplateType.ResponsiveTableCellsExtension);
        const cellManifestSection = manifestSection[cellsPath];
        if (cellManifestSection) {
            fragmentType = cellManifestSection['type'] ? cellManifestSection['type'].toLowerCase() : 'xml';
            fragmentId = cellManifestSection.fragmentName.substr(appId.length + 1);
            fragmentParts = fragmentId.split('.');
            fragmentName = fragmentParts[fragmentParts.length - 1] + types_1.FRAGMENTNAMEPART + fragmentType;
            for (let i = 0; i < fragments.length; i++) {
                const fragment = fragments[i];
                if (fragment['dataSourceUri'].endsWith(fragmentName)) {
                    //fragments.splice(i, 1);
                    const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent));
                    const fragmentColumns = fragmentJson.elements[0].elements &&
                        fragmentJson.elements[0].elements.filter((element) => {
                            return element.type === 'element';
                        });
                    if (fragmentColumns) {
                        for (let index = 0; index < fragmentColumns.length; index++) {
                            if (JSON.stringify(fragmentColumns[index]) === dummyEntryAsString) {
                                fragmentColumns.splice(index, 1);
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
}
exports.deleteColumnFromFragment = deleteColumnFromFragment;
/**
 * Updates the content of a cell fragment file
 * @param fragments - list of existing fragments, to be enhanced
 * @param cellFragmentFileName - file name of the given cell fragment, as calculated from the config entry
 * @param config - current config JSON
 * @returns a boolean value to indicate if the cell fragment could be found n the given list of fragments
 */
function updateCellsFragment(fragments, cellFragmentFileName, config) {
    let cellsFragmentFound = false;
    for (let i = 0; i < fragments.length; i++) {
        const fragment = fragments[i];
        const fragmentPathArray = fragment['dataSourceUri'].split(path_1.sep);
        if (fragmentPathArray[fragmentPathArray.length - 1] === cellFragmentFileName) {
            cellsFragmentFound = true;
            if (!fragment.fileContent || Object.keys(fragment.fileContent).length === 0) {
                // Empty fragment - use template
                fragment.fileContent = view_controller_generator_1.getResponsiveTableCellsFragment(config);
            }
            else {
                const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent));
                const fragmentColumns = fragmentJson.elements[0].elements &&
                    fragmentJson.elements[0].elements.filter((element) => {
                        return element.type === 'element';
                    });
                if (!fragmentColumns || Object.keys(fragmentColumns).length !== Object.keys(config).length) {
                    if (!fragmentColumns || Object.keys(fragmentColumns).length < Object.keys(config).length) {
                        const startIndex = fragmentColumns ? Object.keys(fragmentColumns).length : 0;
                        if (!fragmentJson.elements[0].elements) {
                            fragmentJson.elements[0].elements = [];
                        }
                        for (let index = startIndex; index < Object.keys(config).length; index++) {
                            fragmentJson.elements[0].elements.push(dummyEntry);
                        }
                    }
                    else if (Object.keys(fragmentColumns).length > Object.keys(config).length) {
                        //only dummy entry will be deleted automatically!
                        let noOfEntriesToBeDeleted = Object.keys(fragmentColumns).length - Object.keys(config).length;
                        for (let index = 0; index < Object.keys(fragmentJson.elements[0].elements).length; index++) {
                            if (JSON.stringify(fragmentJson.elements[0].elements[index]) === dummyEntryAsString) {
                                fragmentJson.elements[0].elements.splice(index, 1);
                                noOfEntriesToBeDeleted -= 1;
                                if (noOfEntriesToBeDeleted === 0) {
                                    break;
                                }
                            }
                        }
                    }
                    fragment.fileContent = xml_js_1.json2xml(JSON.stringify(fragmentJson), { spaces: 4 });
                }
            }
            break;
        }
    }
    return cellsFragmentFound;
}
/**
 * The function transfers ALL properties of one or more custom columns to a given fragment, or creates a new one if necesary.
 * @param {ExportResults} exportResults - export result comprising fragments and manifest
 * @param manifestPath - path to the current section of the manifest that describes the extension
 * @param config - current config part, describing the new image of the extension
 * @param appId - application ID
 * @param viewTemplateType - name of the view template that shall be applied
 * @param {ExtensionLogger} logger - logger instance for exceptions
 */
function exportToFragment(exportResults, manifestPath, config, appId, viewTemplateType, logger) {
    var _a;
    const fragments = exportResults.fragments;
    const manifest = exportResults.manifest;
    let cellsFragmentName;
    let lsFilePath;
    //Find and adapt manifest
    const manifestSection = manifest_1.getManifestSectionByPathV2(manifest, manifestPath);
    const fragmentType = manifestSection['type'] ? manifestSection['type'].toLowerCase() : 'xml';
    manifestSection['type'] = fragmentType.toUpperCase();
    for (let index = 0; index < config.length; index++) {
        //last one wins -as there can only be one reference in the manifest
        if (!config[index].fragmentName) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOFRAGMENT', { columnKey: config[index].columnKey })
            });
            continue;
        }
        manifestSection['fragmentName'] = config[index].fragmentName;
        manifestSection['className'] = config[index].className;
        lsFilePath =
            ((_a = config[index].fragmentName) === null || _a === void 0 ? void 0 : _a.replace(appId, '<root>/webapp').replace(/[.]/g, path_1.sep)) +
                types_1.FRAGMENTNAMEPART +
                fragmentType;
    }
    if (manifestPath.indexOf(types_1.ViewTemplateType.ResponsiveTableColumnsExtension) > -1) {
        const cellsPath = manifestPath.replace(types_1.ViewTemplateType.ResponsiveTableColumnsExtension, types_1.ViewTemplateType.ResponsiveTableCellsExtension);
        const cellManifestSection = manifest_1.getManifestSectionByPathV2(manifest, cellsPath);
        const cellsFragmentColumn = config.reduce((previousColumn, column) => {
            return column.cellsFragmentName ? column : previousColumn;
        });
        if (cellsFragmentColumn && cellsFragmentColumn.cellsFragmentName) {
            cellManifestSection['fragmentName'] = cellsFragmentName = cellsFragmentColumn.cellsFragmentName;
            cellManifestSection['className'] = config[0].className;
            cellManifestSection['type'] = fragmentType.toUpperCase();
        }
        else {
            manifest_1.deleteManifestSectionByPathV2(manifest, cellsPath);
        }
    }
    //Find and adapt fragment
    const configColumns = JSON.parse(JSON.stringify(config));
    let fragmentName = manifestSection['fragmentName'];
    let fragmentFound = false;
    let cellsFragmentFound = false;
    const fragmentId = fragmentName.substr(appId.length + 1);
    const fragmentParts = fragmentId.split('.');
    const templateType = fragmentParts[fragmentParts.length - 1];
    fragmentName = templateType + types_1.FRAGMENTNAMEPART + fragmentType;
    const cellFragmentParts = cellsFragmentName === null || cellsFragmentName === void 0 ? void 0 : cellsFragmentName.split('.');
    const cellTemplateType = cellFragmentParts ? cellFragmentParts[cellFragmentParts.length - 1] : null;
    const cellFragmentFileName = cellTemplateType ? cellTemplateType + types_1.FRAGMENTNAMEPART + fragmentType : null;
    if (fragments) {
        //find and update the columns' fragment file
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            if (fragment['dataSourceUri'].endsWith(fragmentName)) {
                let columnsInFragmentDefinition = {};
                fragmentFound = true;
                if (!fragment.fileContent || fragment.fileContent.length === 0) {
                    // Empty fragment - use template
                    fragment.fileContent = view_controller_generator_1.getColumnFragmentContent(configColumns, viewTemplateType);
                }
                else {
                    const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent, { compact: true }));
                    //find the right column in the fragment file
                    columnsInFragmentDefinition = getRootCustomColumnFromFragmentJSON(fragmentJson[exports.FRAGMENT_DEFINITION]);
                    if (columnsInFragmentDefinition) {
                        //find the right column in the identified fragment file
                        if (Array.isArray(columnsInFragmentDefinition)) {
                            for (let j = 0; j < columnsInFragmentDefinition.length; j++) {
                                const columnFoundInConfig = handleFragmentColumn(columnsInFragmentDefinition[j], configColumns);
                                if (!columnFoundInConfig) {
                                    columnsInFragmentDefinition.splice(j, 1);
                                }
                            }
                        }
                        else {
                            const columnFoundInConfig = handleFragmentColumn(columnsInFragmentDefinition, configColumns);
                            if (!columnFoundInConfig) {
                                const tagName = getTagNameFromFragmentJSON(fragmentJson[exports.FRAGMENT_DEFINITION]);
                                if (tagName) {
                                    delete fragmentJson[exports.FRAGMENT_DEFINITION][tagName];
                                    columnsInFragmentDefinition = undefined;
                                }
                            }
                        }
                    }
                    //Insert scenario for the remaining entries
                    for (let j = 0; j < configColumns.length; j++) {
                        if (configColumns[j].fragmentName.endsWith(fragmentId)) {
                            const newColumnFragment = view_controller_generator_1.getSingleColumnContent(configColumns[j], viewTemplateType);
                            if (newColumnFragment) {
                                const newColumnDefinition = JSON.parse(xml_js_1.xml2json(newColumnFragment, { compact: true }));
                                const newColumn = getRootCustomColumnFromFragmentJSON(newColumnDefinition);
                                if (Array.isArray(columnsInFragmentDefinition)) {
                                    columnsInFragmentDefinition.push(newColumn);
                                }
                                else {
                                    if (columnsInFragmentDefinition) {
                                        columnsInFragmentDefinition = [columnsInFragmentDefinition, newColumn];
                                    }
                                    else {
                                        columnsInFragmentDefinition = [newColumn];
                                    }
                                }
                            }
                        }
                    }
                    const tagName = VIEW_TEMPLATE_TAGNAME_MAP.get(viewTemplateType);
                    fragmentJson[exports.FRAGMENT_DEFINITION][tagName] = columnsInFragmentDefinition;
                    fragment.fileContent = xml_js_1.json2xml(JSON.stringify(fragmentJson), { compact: true, spaces: 4 });
                }
                break;
            }
        }
        if (cellsFragmentName) {
            //find an update the cells' fragment file
            cellsFragmentFound = updateCellsFragment(fragments, cellFragmentFileName, config);
        }
        else {
            cellsFragmentFound = true; //not relevant
        }
    }
    if (!fragmentFound) {
        const fragment = {
            fileContent: view_controller_generator_1.getColumnFragmentContent(configColumns, viewTemplateType),
            dataSourceUri: lsFilePath
        };
        exportResults.fragments.push(fragment);
    }
    if (!cellsFragmentFound) {
        const fragment = {
            fileContent: view_controller_generator_1.getResponsiveTableCellsFragment(config),
            dataSourceUri: lsFilePath.replace(fragmentName, cellFragmentFileName)
        };
        exportResults.fragments.push(fragment);
    }
}
exports.exportToFragment = exportToFragment;
/**
 * Determines the manifest path of a column extension.
 * @param {string[]} page Page object from manifest.
 * @param {string} entitySet Table's entity set.
 * @param {string} [additionalKey] Key provided when defining the FacetID or QuickVariantSelectionX.
 * @param {string} [tableColumnExtensionType] Column extension type.
 */
exports.getCustomColumnPath = (page, entitySet, additionalKey, tableColumnExtensionType) => {
    const extension = FE_TEMPLATE_VIEW_EXTENSION_MAP.get(page.component.name);
    if (!tableColumnExtensionType) {
        let tableType = page.component.settings &&
            page.component.settings.tableSettings &&
            page.component.settings.tableSettings['type'];
        if (!tableType) {
            tableType = 'ResponsiveTable';
        }
        if (extension === 'sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage') {
            tableType = 'AnalyticalTable';
        }
        tableColumnExtensionType = tableType + 'ColumnsExtension';
    }
    const viewTemplateType = tableColumnExtensionType;
    let extensionKey = `${tableColumnExtensionType}|${entitySet}`;
    if (additionalKey) {
        extensionKey += '|' + additionalKey;
    }
    const path = 'sap.ui5/extends/extensions/sap.ui.viewExtensions/' + extension + '/' + extensionKey;
    return { path, viewTemplateType };
};
//# sourceMappingURL=Fragment.js.map