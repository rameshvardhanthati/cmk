import { ViewTemplateType } from '../../common';
import { TableCustomColumns, TableCustomColumn } from '../../../specification/v2';
export declare enum ViewTypes {
    XML = "xml",
    HTML = "html",
    JS = "js",
    JSON = "json"
}
export declare enum DirName {
    Sapux = "src",
    Schemas = ".schemas",
    Pages = "pages",
    Webapp = "webapp",
    Temp = ".tmp",
    Changes = "changes",
    LocalService = "localService",
    Controller = "controller",
    View = "view",
    Fragment = "fragment",
    Ext = "ext",
    VSCode = ".vscode"
}
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @return {string} the rendered template's string
 */
export declare const getControllerContent: (name: string, namespace: string, fcl?: boolean, newControllerRouting?: boolean) => string;
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @param {ViewTypes} sourceType - View's source type like XML, HTML, JSON or JS.
 * @param {boolean} [controller=false] - Generate controller.
 * @param {boolean} [page=false] - Is view should contains page structure or not - page structure uses 'sap.m.App' in view template.
 * @return {string} the rendered template's string
 */
export declare const getViewContent: (name: string, namespace: string, sourceType: ViewTypes, controller?: boolean, page?: boolean) => string;
/**
 * Method which reads template for fragment and returns rendered result of fragment.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @param {ViewTypes} sourceType - View's source type like XML, HTML, JSON or JS.
 * @param {boolean} handler - JS handler.
 * @return {string} the rendered template's string
 */
export declare const getFragmentContent: (name: string, namespace: string, sourceType: ViewTypes, handler?: boolean) => string;
/**
 * Method which reads the template for a single column extension that shall be added to a fragment
 * @param {TableCustomColumn} column - data (from config) to be inserted in the template
 * @return {string} the rendered template's string
 */
export declare const getSingleColumnContent: (column: TableCustomColumn, template: ViewTemplateType) => string;
/**
 * Method which reads the template for a column extension fragment and returns rendered result of fragment.
 * @param {TableCustomColumns} customColumns - array of all column extensions' data
 * @return {string} the rendered template's string
 */
export declare const getColumnFragmentContent: (customColumns: TableCustomColumns, templateType: ViewTemplateType) => string;
/**
 * Creates the content for a ResponsiveTableCellsExtesnion fragment
 * @param customColumns - list of custom columns; for each of them a dummy entry gets created in the view content.
 * @returns {string} the rendered template's string
 */
export declare const getResponsiveTableCellsFragment: (customColumns: TableCustomColumns) => string;
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @return {string} the rendered template's string
 */
export declare const getFragmentJsContent: () => string;
