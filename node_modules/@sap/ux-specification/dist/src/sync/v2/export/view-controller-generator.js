"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const ejs_1 = require("ejs");
const fs_1 = require("fs");
const templatesPath = path_1.join(__dirname, 'templates');
var ViewTypes;
(function (ViewTypes) {
    ViewTypes["XML"] = "xml";
    ViewTypes["HTML"] = "html";
    ViewTypes["JS"] = "js";
    ViewTypes["JSON"] = "json";
})(ViewTypes = exports.ViewTypes || (exports.ViewTypes = {}));
var DirName;
(function (DirName) {
    DirName["Sapux"] = "src";
    DirName["Schemas"] = ".schemas";
    DirName["Pages"] = "pages";
    DirName["Webapp"] = "webapp";
    DirName["Temp"] = ".tmp";
    DirName["Changes"] = "changes";
    DirName["LocalService"] = "localService";
    DirName["Controller"] = "controller";
    DirName["View"] = "view";
    DirName["Fragment"] = "fragment";
    DirName["Ext"] = "ext";
    DirName["VSCode"] = ".vscode";
})(DirName = exports.DirName || (exports.DirName = {}));
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} templatePath - Path to template.
 * @param {{ [key: string]: string }} templateData - Template data object.
 * @return {string} the rendered template's string
 */
const renderTemplate = (templatePath, templateData) => {
    const template = fs_1.readFileSync(templatePath, 'utf8');
    const source = ejs_1.render(template, templateData);
    return source;
};
/**
 * Method escapes view name.
 * @param {string} name - View's name.
 * @return {string} Escaped view name.
 */
const escapeViewName = (name) => {
    // Remove all special characters
    return name.replace(/[^\w\s-]/gi, '');
};
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @return {string} the rendered template's string
 */
exports.getControllerContent = (name, namespace, fcl = false, newControllerRouting = false) => {
    const templateData = {
        name: namespace + '.' + escapeViewName(name),
        newControllerRouting
    };
    return renderTemplate(path_1.join(templatesPath, fcl ? 'controllerFcl.js' : 'controller.js'), templateData);
};
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @param {ViewTypes} sourceType - View's source type like XML, HTML, JSON or JS.
 * @param {boolean} [controller=false] - Generate controller.
 * @param {boolean} [page=false] - Is view should contains page structure or not - page structure uses 'sap.m.App' in view template.
 * @return {string} the rendered template's string
 */
exports.getViewContent = (name, namespace, sourceType, controller = false, page = true) => {
    const escapedName = escapeViewName(name);
    const templateData = {
        name: escapedName,
        controllerName: '',
        page
    };
    if (controller) {
        templateData.controllerName = namespace + '.controller.' + escapedName;
    }
    return renderTemplate(path_1.join(templatesPath, 'view.' + sourceType), templateData);
};
/**
 * Method which reads template for fragment and returns rendered result of fragment.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @param {ViewTypes} sourceType - View's source type like XML, HTML, JSON or JS.
 * @param {boolean} handler - JS handler.
 * @return {string} the rendered template's string
 */
exports.getFragmentContent = (name, namespace, sourceType, handler = false) => {
    const escapedName = escapeViewName(name);
    const templateData = {
        name: escapedName,
        handler: ''
    };
    if (handler) {
        templateData.handler = `${namespace.replace(/\./g, '/')}/${DirName.Fragment}/${escapedName}`;
    }
    return renderTemplate(path_1.join(templatesPath, 'fragment.' + sourceType), templateData);
};
/**
 * Method which reads the template for a single column extension that shall be added to a fragment
 * @param {TableCustomColumn} column - data (from config) to be inserted in the template
 * @return {string} the rendered template's string
 */
exports.getSingleColumnContent = (column, template) => {
    const templateData = {
        id: column.id,
        text: column.text,
        columnKey: column.columnKey,
        columnIndex: column.columnIndex !== undefined ? column.columnIndex.toString() : undefined,
        leadingProperty: column.leadingProperty
    };
    return renderTemplate(path_1.join(templatesPath, template + '.xml'), templateData);
};
/**
 * Method which reads the template for a column extension fragment and returns rendered result of fragment.
 * @param {TableCustomColumns} customColumns - array of all column extensions' data
 * @return {string} the rendered template's string
 */
exports.getColumnFragmentContent = (customColumns, templateType) => {
    let fragment = '';
    fragment = '<core:FragmentDefinition xmlns:core="sap.ui.core" xmlns:table="sap.ui.table" xmlns="sap.m">';
    if (customColumns) {
        for (let index = 0; index < customColumns.length; index++) {
            const column = customColumns[index];
            const newContent = exports.getSingleColumnContent(column, templateType);
            fragment = fragment + '\n' + newContent;
        }
    }
    return fragment + '\n' + '</core:FragmentDefinition>';
};
/**
 * Creates the content for a ResponsiveTableCellsExtesnion fragment
 * @param customColumns - list of custom columns; for each of them a dummy entry gets created in the view content.
 * @returns {string} the rendered template's string
 */
exports.getResponsiveTableCellsFragment = (customColumns) => {
    let fragment = '<core:FragmentDefinition xmlns:core="sap.ui.core" xmlns="sap.m">';
    if (customColumns) {
        for (let index = 0; index < customColumns.length; index++) {
            fragment = fragment + '\n<Text text="Placeholder"></Text>';
        }
    }
    return fragment + '\n' + '</core:FragmentDefinition>';
};
/**
 * Method which reads passed template and renders it using passed template object.
 * @param {string} name - View's name.
 * @param {string} namespace - Application namespace.
 * @return {string} the rendered template's string
 */
exports.getFragmentJsContent = () => {
    return renderTemplate(path_1.join(templatesPath, 'fragment.js'), {});
};
//# sourceMappingURL=view-controller-generator.js.map