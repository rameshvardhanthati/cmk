"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const flexibleColumnLayout_1 = require("./flexibleColumnLayout");
const v4_1 = require("../../../v4");
const utils_1 = require("../../common/utils");
const factory_1 = require("./factory");
/**
 * Return the skeleton of a exportResultManifest's "sap.ui.generic.app" entry, prefilled with some values
 * @param name - name of the template, e.g. "sap.suite.ui.generic.template.ObjectPage"
 * @param entitySet - the main entity set
 * @param navigationProperty - navigation property
 */
const getV4ManifestPageTemplate = (name, entitySet) => {
    const V4Page = {
        type: 'Component',
        id: '',
        name: name,
        options: {
            settings: {
                entitySet: entitySet,
                navigation: {},
                controlConfiguration: {}
            }
        }
    };
    return V4Page;
};
const defaultExportResult = {
    flexChanges: [],
    manifest: {
        'sap.ui5': {
            flexEnabled: true,
            routing: {
                targets: {}
            }
        },
        'sap.app': {}
    },
    fragments: []
};
/**
 * Applies the sync rule for a flex change during eport
 * @param syncRule - export rule from the object classes decorator
 * @param transferParameters - list of parameters passed from API
 * @param ids - list of parent & child ids
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param configObject - current (sub)object of the configuration file
 * @param key - key of the given property
 */
function exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key) {
    const controlId = syncRule.flex.controlId(transferParameters.baseId, ids, breadcrumbs, syncRule.flex.controlType, transferParameters.title);
    const flexChange = common_1.fillFlexChangeContent(configObject, syncRule, transferParameters.ui5Version, key, controlId);
    transferParameters.exportResults.flexChanges.push(syncRule.flex.createFlexChange(flexChange, transferParameters.exportResults.manifest));
}
function determineTargetAnnotation(ids, title) {
    let targetAnnotation = '', targetAnnotationEncoded = '', custom = false;
    if (ids[0] === 'sections') {
        if (ids[1] === 'custom' && ids[2] !== ids[ids.length - 1]) {
            custom = true;
            targetAnnotationEncoded = ids[2];
            targetAnnotation = targetAnnotationEncoded.replace(/::/g, '/');
        }
        else {
            targetAnnotationEncoded = ids[1] && ids[1].replace(/\//g, '::');
            targetAnnotation = targetAnnotationEncoded.replace(/::/g, '/');
        }
    }
    if (ids[1] === 'sections') {
        //header sections
        targetAnnotation = targetAnnotationEncoded =
            title && title.indexOf(v4_1.FacetTitlePrefix) > -1
                ? title.split(v4_1.FacetTitlePrefix)[1]
                : targetAnnotationEncoded.replace(/::/g, '/');
    }
    return { targetAnnotationEncoded, targetAnnotation, custom };
}
function getColumnKey(ids) {
    let columnKey;
    const isDataField = (element) => element === 'columns' || element === 'actions';
    const columnKeyIndex = ids.findIndex(isDataField) + 1;
    if (columnKeyIndex > 0) {
        columnKey = ids[columnKeyIndex];
    }
    return columnKey;
}
function transferPropertyToManifest(propertyDefinition, nextDefinition, syncRule, manifestSection, configObject, key, manifestKey) {
    if (!(propertyDefinition['type'] !== 'array' &&
        nextDefinition &&
        nextDefinition['targetDefinition'].type === 'object' &&
        nextDefinition['targetDefinition'].properties)) {
        const exportHandler = syncRule.manifest.export;
        if (exportHandler !== false) {
            if (exportHandler && typeof exportHandler === 'function') {
                exportHandler(manifestSection, configObject, key, manifestKey);
            }
            else {
                manifestSection[manifestKey] = configObject[key];
            }
        }
    }
    else if (propertyDefinition['type'] !== 'array' && manifestSection[manifestKey] === undefined) {
        manifestSection[manifestKey] = {};
    }
}
function exportManifestChange(ids, syncRule, transferParameters, key, configObject, propertyDefinition, nextDefinition) {
    //eliminate subsections' hierarchy
    let index = ids.indexOf('subsections');
    while (index > -1) {
        ids.splice(index - 1, 2);
        index = ids.indexOf('subsections');
    }
    const { targetAnnotationEncoded, targetAnnotation, custom } = determineTargetAnnotation(ids, transferParameters.title);
    const columnKey = getColumnKey(ids);
    const path = syncRule.manifest.path(transferParameters.pageNameArray, {}, targetAnnotationEncoded, columnKey);
    const manifestSection = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path, targetAnnotation, custom ? undefined : targetAnnotationEncoded);
    const manifestKey = syncRule.manifest.key || key;
    if (configObject[key] !== undefined) {
        // In case of arrays we take over complete array
        transferPropertyToManifest(propertyDefinition, nextDefinition, syncRule, manifestSection, configObject, key, manifestKey);
    }
    else if (manifestSection[manifestKey] !== undefined) {
        delete manifestSection[manifestKey];
    }
    else if (syncRule.manifest.delete) {
        const deleteHandler = syncRule.manifest.delete;
        if (typeof deleteHandler === 'function') {
            deleteHandler(manifestSection, configObject, key, manifestKey);
        }
    }
    utils_1.deleteEmptyStructure(transferParameters.exportResults.manifest, path, targetAnnotation, targetAnnotationEncoded);
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param transferParameters - list of parameters passed from API
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param key - key of the given property
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param propertyDefinition - schema definiton of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function evaluateExportRule(transferParameters, breadcrumbs, key, configObject, ids, propertyDefinition, nextDefinition) {
    const syncRule = common_1.getReflectMetadata(configObject, key);
    if (syncRule) {
        if (syncRule.flex) {
            exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key);
        }
        else if (syncRule.manifest) {
            exportManifestChange(ids, syncRule, transferParameters, key, configObject, propertyDefinition, nextDefinition);
        }
    }
}
function transferSubObject(propertyDefinition, nextDefinition, currentConfigObject, breadcrumbs, key, transferParameters, ids, localIdParts) {
    let objects = [], isArray = false;
    if (propertyDefinition.$ref && nextDefinition) {
        objects.push(nextDefinition.configObject);
    }
    else if (propertyDefinition['anyOf']) {
        objects.push(currentConfigObject);
    }
    else if (propertyDefinition.type === 'array') {
        objects = currentConfigObject;
        isArray = true;
    }
    else {
        objects.push(currentConfigObject);
    }
    for (const innerObject of objects) {
        const additionalIds = [];
        if (breadcrumbs[0] === 'sections' && key === 'custom' && isArray) {
            // We need add custom section 'id' into breadcrumbs to retrieve correct path to manifest
            additionalIds.push(innerObject['id']);
        }
        transferParameters.title = nextDefinition.title;
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, innerObject, [...ids, ...additionalIds], localIdParts, [...breadcrumbs, key], nextDefinition.targetDefinition);
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills exportResultManifest entries and flex changes
 * @param transferParameters - list of parameters passed from API
 * @param configObject - current object to traverse
 * @param parentIds - array of collected parent ids
 * @param stableIdParts - list of parts of the stable ID for flex changes
 * @param breadcrumbs - array of sequence of properties that we are currently processing. Required for instance for table column name
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - the title to be used for the given schema definition
 */
function transferManifestEntriesAndFlexChange(transferParameters, configObject, parentIds, stableIdParts, breadcrumbs, schemaDefinition) {
    let currentConfigObject;
    if (schemaDefinition && schemaDefinition['properties']) {
        for (const key in schemaDefinition['properties']) {
            currentConfigObject = configObject[key];
            const childId = common_1.getChildId(configObject, key);
            const propertyDefinition = schemaDefinition['properties'][key];
            const nextDefinition = utils_1.getNextTargetDefinition(transferParameters.appSchema, transferParameters.title, currentConfigObject, propertyDefinition, key, transferParameters.factory, transferParameters.pageType);
            const ids = childId ? [...parentIds, childId] : [...parentIds, key];
            evaluateExportRule(transferParameters, breadcrumbs, key, configObject, ids, propertyDefinition, nextDefinition);
            if (propertyDefinition &&
                (typeof currentConfigObject === 'object' || (propertyDefinition.$ref && nextDefinition.configObject))) {
                const localIdParts = childId ? [...stableIdParts, childId] : stableIdParts;
                transferSubObject(propertyDefinition, nextDefinition, currentConfigObject, breadcrumbs, key, transferParameters, ids, localIdParts);
            }
        }
    }
}
/**
 * Instantiates the export classes for a single object page section
 * @param sectionId - Current section ID
 */
function getClassesForSingleSection(objectPageConfig, sectionId, factory) {
    if (sectionId === 'custom' && Array.isArray(objectPageConfig.sections[sectionId])) {
        // Custom sections
        const customSections = objectPageConfig.sections.custom;
        for (let index = 0; index < customSections.length; index++) {
            customSections[index] = factory.createInstance(v4_1.PageType.ObjectPage, 'ObjectPageCustomSectionView', customSections[index], customSections[index].className);
        }
    }
}
/**
 * Recursive sub-function for handling subsections
 * @param section - Object page section in config
 */
function getSubsectionClasses(section, factory) {
    if (section['subsections']) {
        let subSection;
        for (const subSectionId in section['subsections']) {
            subSection = section['subsections'][subSectionId];
            getClassesForSingleSection(subSection, subSectionId, factory);
            getSubsectionClasses(subSection, factory);
        }
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, factory) {
    let section;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        getClassesForSingleSection(objectPageConfig, sectionId, factory);
        getSubsectionClasses(section, factory);
    }
}
/**
 * Run through the given ObjectPage config and return respective exportResultManifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param manifest - manifest of the application
 * @param pageName - routing target defined in manfiest
 */
const exportObjectPage = (exportParameters, ui5Version) => {
    var _a;
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const objectPage = factory.createPageInstance(v4_1.PageType.ObjectPage, exportParameters.page.config);
    const pageLayoutInformation = common_1.getPageLayoutInformation(objectPage);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    if ((_a = exportParameters.page.config) === null || _a === void 0 ? void 0 : _a['sections']) {
        getExportClassesForSections(exportParameters.page.config, objectPage, factory);
    }
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        baseId,
        appSchema: exportParameters.jsonSchema,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: v4_1.PageType.ObjectPage,
        title: undefined
    };
    transferManifestEntriesAndFlexChange(transferParameters, objectPage, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    exportParameters.jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given List Page (LR or ALP) config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 * @param config - content of the config file
 * @param {PageTypeV4} - pageType - Page type
 * @param ui5Version - SAP UI5 version
 */
const exportListPage = (exportParameters, factory, config, pageType, ui5Version) => {
    var _a;
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    config.table = factory.createInstance(pageType, 'Table', config.table);
    if ((_a = config.table.toolBar) === null || _a === void 0 ? void 0 : _a.actions) {
        for (const actionKey in exportParameters.jsonSchema['definitions']['Actions<LineItems>'].properties) {
            config.table.toolBar.actions[actionKey] = factory.createInstance(pageType, 'ToolBarAction', config.table.toolBar.actions[actionKey]);
        }
    }
    const pageLayoutInformation = common_1.getPageLayoutInformation(config);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    if (!exportResults.manifest[v4_1.ManifestSection.ui5]['routing']['targets'][pageName]) {
        const newV4Page = getV4ManifestPageTemplate(pageLayoutInformation.pageId, pageName);
        exportResults.manifest[v4_1.ManifestSection.ui5]['routing']['targets'][pageName] = newV4Page;
    }
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        baseId,
        appSchema: exportParameters.jsonSchema,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: v4_1.PageType.ListReport,
        title: undefined
    };
    transferManifestEntriesAndFlexChange(transferParameters, config, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    exportParameters.jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ListReport config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 *
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportListReportPage = (exportParameters, ui5Version) => {
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const listReport = factory.createPageInstance(v4_1.PageType.ListReport, exportParameters.page.config);
    return exportListPage(exportParameters, factory, listReport, v4_1.PageTypeV4.ListReport, ui5Version);
};
/**
 * Run through the given Analytical List Page config and return respective exportResultManifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param analyticalListPageConfig - content of the Analytical List page config file
 * @param pageName - routing target defined in manifest
 *
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportAnalyticalListPage = (exportParameters, ui5Version) => {
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const analyticalListPage = factory.createPageInstance(v4_1.PageType.AnalyticalListPage, exportParameters.page.config);
    return exportListPage(exportParameters, factory, analyticalListPage, v4_1.PageTypeV4.AnalyticalListPage, ui5Version);
};
/**
 * API for the export of a V4 app configuration
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param application - V4 application (app.json config file)
 * @param manifest - Manifest of the given app
 * @param jsonSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
const exportApplicationV4 = (application, manifest, jsonSchema) => {
    const exportResults = defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    const applicationV4 = Object.assign(new application_1.ApplicationV4(), application);
    //transform application settings
    applicationV4.settings = Object.assign(new application_1.AppSettings(), applicationV4.settings);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const syncRule = common_1.getReflectMetadata(applicationV4.settings, key);
        if (syncRule && syncRule.manifest) {
            const path = syncRule.manifest.path();
            const manifestSection = common_1.getManifestSectionByPathV4(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key]) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
            utils_1.deleteEmptyStructure(exportResults.manifest, path);
        }
    }
    //transform routing
    exportResults.manifest[v4_1.ManifestSection.ui5].routing = manifest_1.transformRoutingV4(application['home'], application['pages'], exportResults.manifest);
    // Update FCL data
    flexibleColumnLayout_1.updateFcl(exportResults.manifest[v4_1.ManifestSection.ui5], application);
    return exportResults;
};
/**
 * General API for the export of a V4 config page
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param appId - Application ID
 * @param page - Current page (config)
 * @param manifest - Manifest of the given app
 * @param jsonSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
exports.exportPageV4 = (exportParametersV4, ui5Version) => {
    if (exportParametersV4[v4_1.SchemaType.ListReport]) {
        return exportListReportPage(exportParametersV4[v4_1.SchemaType.ListReport], ui5Version);
    }
    else if (exportParametersV4[v4_1.SchemaType.ObjectPage]) {
        return exportObjectPage(exportParametersV4[v4_1.SchemaType.ObjectPage], ui5Version);
    }
    else if (exportParametersV4[v4_1.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV4[v4_1.SchemaType.Application];
        return exportApplicationV4(application, manifest, jsonSchema);
    }
    else if (exportParametersV4[v4_1.SchemaType.AnalyticalListPage]) {
        return exportAnalyticalListPage(exportParametersV4[v4_1.SchemaType.AnalyticalListPage], ui5Version);
    }
};
//# sourceMappingURL=export.js.map